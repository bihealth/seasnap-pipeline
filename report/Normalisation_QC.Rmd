## Normalisation quality control metrics {.tabset}

```{r normalisationQCsetup}
require(magrittr)

#----- load DESeqDataSet
dds <- readRDS(subset(file_tab, step=="DESeq2" & extension=="deseq2.rds" & contrast=="all")$filename)
rld_blind <- readRDS(subset(file_tab, step=="DESeq2" & extension=="rld.blind.rds" & contrast=="all")$filename)
rld_model <- readRDS(subset(file_tab, step=="DESeq2" & extension=="rld.model.rds" & contrast=="all")$filename)

report_dir <- file.path(working_dir, dirname(subset(file_tab, step=="report" & extension=="tsv" & contrast=="all")$filename))
plots_dir <- file.path(report_dir, "plots", "NormalisationQC")
dir.create(plots_dir, recursive=TRUE, showWarnings=FALSE, mode="0750")
```

### Principal component analysis

The principal component analysis plot shown below was generated using the most varying `r config$report$snippet_parameters$Normalisation_QC$n_most_varying` genes across all samples.
The expression values are obtained by the "`r config$normalization$normalized_expression`" method, where the normalisation doesn't take into account the experimental design.

In presence of strong biological signal, the samples should cluster with the biological condition.
When samples are clustered according to other effects (for example patient, or technical batch), great care must be used when interpreting the results, as the other effects will considerably reduce the ability to extract meaningful biological information.

```{r normalisationQCPCA}
intgroups <- config$report$snippet_parameters$Normalisation_QC$annotation_columns
intgroups <- intgroups[1:min(2,length(intgroups))]
tmp <- plotPCA(rld_blind, intgroup=intgroups, returnData=TRUE)
percentVar <- 100 * attr(tmp, "percentVar")

if (length(intgroups) == 1) {
    p <- ggplot2::ggplot(tmp, ggplot2::aes_string(x="PC1", y="PC2", color=intgroups[1]))
} else {
    p <- ggplot2::ggplot(tmp, ggplot2::aes_string(x="PC1", y="PC2", color=intgroups[1], shape=intgroups[2]))
}
p <- p +
    ggplot2::geom_point(size=3) +
    ggplot2::labs(x=sprintf("PC1: %.0f %% variance", percentVar[1]), y=sprintf("PC2: %.0f %% variance", percentVar[2])) + 
    ggplot2::coord_fixed()

fn <- file.path(plots_dir, "PCA.pdf")
multiplot(p, fn=fn)
```

[Download plot](`r fn`)

### Hierarchical clustering

The hierarchical clustering shown below was generated using the most varying `r config$report$snippet_parameters$Normalisation_QC$n_most_varying` genes across all samples.
The expression values are obtained by the "`r config$normalization$normalized_expression`" method, where the normalisation doesn't take into account the experimental design.
The clustering is using euclidian distance for both the rows (genes) and columns (samples). In both cases, the distance between clusters is defined as the maximum of the distances between elements pairs from each cluster.

The hierarchical clustering can provide clues on which groups of genes could affect the clustering of samples.

```{r normalisationQCHclust}
tmp <- SummarizedExperiment::assay(rld_blind)
tmp <- tmp[order(apply(tmp, 1, sd), decreasing=TRUE),,drop=FALSE]
tmp <- tmp[1:min(nrow(tmp), config$report$snippet_parameters$Normalisation_QC$n_most_varying),,drop=FALSE]

fn <- file.path(plots_dir, "HClust.pdf")
p <- ggplotify::as.ggplot(pheatmap::pheatmap(tmp, show_rownames=(nrow(tmp)<=30), silent=TRUE))
multiplot(p, fn=fn)
```

[Download plot](`r fn`)

### Sample similarity

The hierarchical clustering shown below was generated using all the full normalised dataset (`r nrow(dds)` genes).
The expression values are obtained by the "`r config$normalization$normalized_expression`" method, where the normalisation doesn't take into account the experimental design.
The clustering is using euclidian distance for both the rows (genes) and columns (samples). In both cases, the distance between clusters is defined as the maximum of the distances between elements pairs from each cluster.

```{r normalisationQCSimilarity}
d <- dist(t(SummarizedExperiment::assay(rld_blind)))
dMatrix <- as.matrix(d)

fn <- file.path(plots_dir, "Similarity.pdf")
p <- ggplotify::as.ggplot(pheatmap::pheatmap(
    dMatrix,
    clustering_distance_rows=d, clustering_distance_cols=d,
    label_rows=colnames(rld_blind), label_cols=NULL,
    col=colorRampPalette(rev(RColorBrewer::brewer.pal(9, "Blues")))(255),
    silent=TRUE
))
multiplot(p, fn=fn)
```

[Download plot](`r fn`)

### Normalised expression densities

The expression values are obtained by the "`r config$normalization$normalized_expression`" method, where the experimental design has been used for normalisation.

```{r normalisationQCDensity}
tmp <- SummarizedExperiment::assay(rld_model)

fn <- file.path(plots_dir, "Densities.pdf")
p <- data.frame(gene_id=rownames(tmp), tmp, check.names=FALSE) %>%
    tidyr::gather(Sample, Expression, -gene_id) %>%
    ggplot2::ggplot(ggplot2::aes(x=Expression, color=Sample)) +
    ggplot2::geom_density()
multiplot(p, fn=fn)
```

[Download plot](`r fn`)

### DESeq2 normalisation

```{r normalisationQCDeseq2prepare, include=FALSE}
DESeq2::plotDispEsts(dds)
gridGraphics::grid.echo()
ps <- list(ggplotify::as.ggplot(grid::grid.grab()))
```

```{r normalisationQCDeseq2, fig.height=7, fig.width=12}
ps <- c(ps, list(vsn::meanSdPlot(SummarizedExperiment::assay(rld_model), plot=FALSE)$gg))

fn <- file.path(plots_dir, "DESeq2_norm.pdf")
multiplot(plotlist=ps, cols=2, fn=fn)
```

[Download plot](`r fn`)

### Cox outliers

```{r normalisedQCOutliers}
p <- data.frame(gene_id=rownames(dds), SummarizedExperiment::assays(dds)[["cooks"]], check.names=FALSE) %>%
    tidyr::gather(Sample, cook, -gene_id) %>%
    dplyr::mutate(cook=log10(cook)) %>%
    ggplot2::ggplot(ggplot2::aes(x=Sample, y=cook)) +
    ggplot2::geom_boxplot() + 
    ggplot2::theme(axis.text.x=ggplot2::element_text(angle=90, vjust=0.5, hjust=1))

fn <- file.path(plots_dir, "cook.pdf")
multiplot(p, fn=fn)
```

[Download plot](`r fn`)
